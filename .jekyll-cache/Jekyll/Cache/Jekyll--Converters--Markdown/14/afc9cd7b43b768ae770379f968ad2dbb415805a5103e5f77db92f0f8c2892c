I"'<h2 id="boj-2125-mothy">[BOJ 2125] Mothy</h2>

<p>문제 출처 : https://www.acmicpc.net/problem/2125</p>

<h2 id="풀이">풀이</h2>

<p>기하문제이다. 기하문제는 정말이지 즐겁다^^</p>

<p>기하문제이기 때문에 기본적으로 CCW를 사용하게 되는데, 문제의 조건에 따라</p>

<ol>
  <li>볼록다각형의 테두리는 지나갈 수 있음</li>
  <li>그러므로 다각형이 맞닿아 있는 곳도 지나갈 수 있음</li>
</ol>

<p>을 생각해서 CCW를 구현해 주어야 한다.</p>

<p>뿐만 아니라, 소수점까지 계산해야하는 문제이기에, 정수 또는 소수 처리를 잘 해주어야 한다.</p>

<p>의식의 흐름대로 풀이를 정리하면 아래와 같다.</p>

<ol>
  <li>모든 볼록다각형의 정점(<em>convex</em>), 시작점과 끝점을 포함한 모든 다각형의 모든 정점(<em>node</em>)를 기억한다.</li>
  <li>각 정점들이 볼록다각형(<em>convex</em>)안에 존재(<em>isIn</em>)하는지 미리 판단한다. 볼록다각형에 존재한다면 해당 정점은 향후에 계산해 줄 필요가 없다. 갈 수 없는 정점이므로.</li>
  <li>다각형 밖에 있는 정점(<em>out_conv</em>, <em>i</em>)인 정점들을 대상으로 다른 다각형 밖에 있는 정점(<em>j</em>)들로 직선 거리로 갈 수 있는지 계산(<em>isCross</em>)한다.</li>
  <li>이 때, <em>i</em> 에서 <em>j</em> 의 중점 역시 다각형 안에 존재하는지 확인(<em>isIn</em>)한다.</li>
  <li>3과 4의 과정을 모두 통과한다면 <em>i</em> 에서 <em>j</em> 의 직선 거리를 계산해서 기억한다.</li>
  <li>마음에 드는 최단 경로 알고리즘으로 시작점에서 끝점까지의 최단 경로를 계산한다.</li>
</ol>

<p>```cpp {numberLines: true}
#include <iostream>
#include <vector>
#include <queue>
#include <cmath>
#include <cstdlib>
#include <functional>
#include <algorithm>
#define min2(x,y) (x&lt;y?x:y)
#define max2(x,y) (x&gt;y?x:y)</algorithm></functional></cstdlib></cmath></queue></vector></iostream></p>

<p>using namespace std;
typedef long long ll;
typedef pair&lt;double, int&gt; pdi;</p>

<p>const int MAXN = 310;</p>

<p>struct Point {
	int x, y;
	Point operator- (const Point a)const {
		return{ x - a.x, y - a.y };
	}
	Point operator+ (const Point a)const {
		return{ x + a.x, y + a.y };
	}
} s, e;</p>

<p>Point operator* (const Point &amp;a, const ll b) {
	return{ a.x<em>b,a.y</em>b };</p>

<p>}
vector<Point> convex[MAXN], node;
double d[MAXN];
priority_queue&lt;pdi, vector<pdi>, greater<pdi> &gt; pq;
bool out_conv[MAXN];
vector<pdi> dist[MAXN];</pdi></pdi></pdi></Point></p>

<p>ll outer(Point A, Point B) {
	ll t = A.x<em>B.y - A.y</em>B.x;
	return t &lt; 0 ? -1 : t&gt;0;
}</p>

<p>ll CCW(Point A, Point B, Point C) {
	return outer(B - A, C - A);
}</p>

<p>bool isCross(Point A, Point B, Point C, Point D) {
	ll abc = CCW(A, B, C);
	ll abd = CCW(A, B, D);
	ll cda = CCW(C, D, A);
	ll cdb = CCW(C, D, B);
	ll ab = abc<em>abd;
	ll cd = cda</em>cdb;
	if (ab &lt; 0 &amp;&amp; cd &lt; 0) return 1;
	if (cd &lt; 0 &amp;&amp; (abc^abd)) return 1;
	return 0;
}</p>

<p>ll square(ll x, ll y) {
	return x<em>x + y</em>y;
}</p>

<p>bool isIn(Point M, int idx) {
	ll ccw = CCW(convex[idx].back() * 2, convex[idx][0] * 2, M);
	for (int i = 0; i &lt; convex[idx].size() - 1; i++) {
		if (ccw != CCW(convex[idx][i] * 2, convex[idx][i + 1] * 2, M)) return 0;
	}
	return 1;
}</p>

<p>int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int N;
cin &gt;&gt; N &gt;&gt; s.x &gt;&gt; s.y &gt;&gt; e.x &gt;&gt; e.y;
node.push_back(s);
for (int i = 1; i &lt;= N; i++) {
	int M;
	cin &gt;&gt; M;
	for (int j = 0; j &lt; M; j++) {
		Point K;
		cin &gt;&gt; K.x &gt;&gt; K.y;
		convex[i].push_back(K);
		node.push_back(K);
	}
}
node.push_back(e);
for (int i = 0; i &lt; node.size(); i++) {
	bool flag = true;
	for (int k = 1; k &lt;= N &amp;&amp; flag; k++) {
		flag &amp;= !isIn(node[i] * 2, k);
	}
	out_conv[i] = flag;
}
for (int i = 0; i &lt; node.size(); i++) {
	if (!out_conv[i]) continue;
	for (int j = i + 1; j &lt; node.size(); j++) {
		if (!out_conv[j]) continue;
		bool flag = true;
		for (int k = 1; k &lt;= N &amp;&amp; flag; k++) {
			for (int l = 0; l &lt; convex[k].size() - 1 &amp;&amp; flag; l++) {
				flag &amp;= !isCross(node[i], node[j], convex[k][l], convex[k][l + 1]);
			}
			flag &amp;= !isIn(node[i] + node[j], k);
			flag &amp;= !isCross(node[i], node[j], convex[k].back(), convex[k][0]);
		}
		if (!flag) continue;

		double dista = sqrt(square(node[i].x - node[j].x, node[i].y - node[j].y));
		dist[i].push_back({ dista,j });
		dist[j].push_back({ dista,i });
	}
}
for (int i = 1; i &lt; node.size(); i++) d[i] = 1e9;
d[0] = 0;
pq.push({ 0,0 });
while (!pq.empty()) {
	double val = pq.top().first;
	int here = pq.top().second;
	pq.pop();
	if (d[here] &lt; val) continue;
	for (pdi k : dist[here]) {
		if (d[k.second] &gt; d[here] + k.first) {
			d[k.second] = d[here] + k.first;
			pq.push({ d[k.second],k.second });
		}
	}
}
if (d[node.size() - 1] &gt;= 1e9) cout &lt;&lt; -1;
else {
	cout.precision(5);
	cout &lt;&lt; fixed &lt;&lt; d[node.size() - 1];
}
return 0; } ```
</code></pre></div></div>

<h2 id="조심해야할-부분">조심해야할 부분</h2>

<ol>
  <li>정점이 볼록 다각형 내부에 위치하는지 판별을 정확히 해주어야한다.</li>
  <li>맞닿은 부분 및 다각형의 모서리 위를 지나갈 수 있기에 CCW를 잘 구현해야한다.</li>
</ol>

<h2 id="개선할-점">개선할 점</h2>

<p>잔 실수를 줄여보자.</p>
:ET